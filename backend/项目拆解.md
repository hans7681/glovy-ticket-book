# 项目拆解学习记录

## 第一部分：项目概述与环境

### 1.1 项目目标与核心功能解读

**目标：** 理解这个电影院购票网站项目旨在解决什么问题，以及它为不同类型的用户提供了哪些核心功能。

**核心功能解读 (基于 `项目需求.md`):**

这个项目旨在模拟一个真实的在线电影票预订系统，服务三种主要角色的用户：

1.  **系统管理员 (SYSTEM_ADMIN):**
    *   **权限:** 拥有最高权限，可以管理整个系统的数据。
    *   **核心功能:**
        *   后台管理：登录、个人信息修改、密码修改。
        *   系统监控：查看票房统计图表 (折线图、饼图、柱状图)。
        *   基础数据管理：管理电影类型、电影信息 (包括状态控制)、演职人员信息、影厅信息、公告信息、用户信息、其他管理员信息。
        *   业务流程管理：审批影院提交的放映申请、管理所有订单信息、管理影院信息 (包括认证)。

2.  **影院管理员 (CINEMA_ADMIN):**
    *   **权限:** 管理自己所属影院的相关信息和业务。
    *   **核心功能:**
        *   影院管理：注册 (需要系统管理员认证)、登录、个人信息修改、密码修改。
        *   信息查看：查看系统公告。
        *   影院运营：管理本影院的放映场次 (提交放映申请)、管理本影院的影厅信息 (默认8x8座位)、管理购买本影院电影票的订单信息。

3.  **普通用户 (USER):**
    *   **权限:** 浏览电影信息、购票、管理个人订单等。
    *   **核心功能:**
        *   基础功能：注册、登录、个人信息修改、密码修改。
        *   浏览与发现：查看首页信息 (热门电影、待映电影、排名、票房)、浏览所有电影信息 (支持筛选)、查看影院信息、查看电影排行榜。
        *   购票流程：在线选座 (选择电影和影院后)、下单。
        *   个人管理：管理自己的订单 (查询、支付前取消)、收藏/取消收藏电影、对电影进行评分。

**关键特性与创新点:**

*   **角色分离:** 清晰区分了不同用户的职责和权限。
*   **完整流程:** 模拟了从电影信息管理、排片、用户选座、下单、支付 (虽然可能是模拟的) 到订单管理的完整业务流程。
*   **数据可视化:** 使用 Echarts 图表进行数据统计展示。
*   **真实模拟:** 模拟在线选座、多影院多影厅运营、预告片播放等。
*   **复杂关联:** 处理影院、影厅、电影、场次、座位、订单等多个模块之间复杂的数据关系。
*   **审批流程:** 包含影院入驻认证、放映场次申请审批等工作流。

**总结:** 这个项目的目标是创建一个功能相对完善、贴近实际运营场景的在线电影票务平台，重点在于多角色权限管理、核心业务流程的实现以及数据之间的复杂关联处理。

### 1.2 技术栈分析

**什么是技术栈？**

技术栈（Technology Stack）是指构建和运行一个应用程序所需的一组技术、软件和工具的集合。通常包括编程语言、框架、数据库、服务器、前端库等等。

**本项目技术栈分析 (基于 `pom.xml` 和 `项目进度.md`):**

根据 `项目进度.md` 文件明确指出，本项目主要使用了以下技术：

1.  **后端 (Server-side):**
    *   **Java:** 主要的编程语言。
    *   **Spring Boot:** 核心框架。它简化了基于 Spring 框架的 Java 应用程序的创建和部署，提供了快速开发、自动配置、内嵌服务器等特性。在这个项目中，它负责处理业务逻辑、API 接口、数据访问等后端任务。
    *   **MyBatis:** 数据持久层框架。它帮助我们将 Java 对象与数据库中的记录进行映射，简化了数据库操作的代码。相比于 JPA/Hibernate，MyBatis 提供了更灵活的 SQL 控制。
    *   **Maven:** 项目管理和构建工具。用于管理项目的依赖库（比如 Spring Boot, MyBatis 等），以及编译、测试、打包项目。`pom.xml` 是它的核心配置文件。
    *   **(可能) Spring Security:** 用于处理用户认证和权限控制。虽然 `项目进度.md` 提到了，但我们需要在后续分析 `pom.xml` 或代码时确认。

2.  **前端 (Client-side):**
    *   **Vue.js:** 一个流行的 JavaScript 框架，用于构建用户界面。它采用组件化的方式开发，使得前端代码更易于管理和复用。在这个项目中，它负责展示用户看到的页面、与用户交互、调用后端 API 获取数据等。

3.  **数据库 (Database):**
    *   **MySQL:** 一个广泛使用的关系型数据库管理系统。用于存储项目的所有数据，如用户信息、电影信息、订单数据等。`数据库设计.md` 文件详细描述了数据库的表结构。

4.  **API 文档:**
    *   **(可能) Swagger:** 用于生成和展示 API 文档。`swagger3.json` 或 `接口API文档.json` 文件很可能就是用它生成的，方便前后端开发者理解和对接接口。

**总结:** 这个项目采用的是经典的 Java Web 开发技术栈，后端使用 Spring Boot + MyBatis 与 MySQL 数据库交互，前端使用 Vue.js 构建用户界面。这是一个非常成熟且应用广泛的技术组合。

### 1.3 项目文件结构概览

**为什么需要了解文件结构？**

想象一下图书馆，如果书没有分类和编号，找一本书会非常困难。项目文件结构就像图书馆的分类系统，良好的结构能让代码清晰、易于维护和协作。

**本项目文件结构概览 (结合之前的 `list_dir` 结果):**

我们之前通过 `list_dir` 看到了根目录的文件，现在我们重点关注那些与代码和配置相关的部分：

1.  **`src/` 目录:** 这是最重要的目录，包含了项目的所有源代码和资源文件。
    *   `src/main/java/`: 存放 **后端 Java 源代码** 的地方。这里面会按照包（package）来组织代码，通常会包含 Controller, Service, Mapper/DAO, Entity/Model, Config 等不同层级的代码。我们之后会深入这个目录查看具体的后端逻辑。
    *   `src/main/resources/`: 存放 **后端资源文件**。
        *   `application.properties` 或 `application.yml`: Spring Boot 的核心配置文件，包含数据库连接信息、服务器端口、日志配置等。
        *   `static/`: 存放静态资源，如 CSS, JavaScript, 图片等（如果不由前端框架处理）。
        *   `templates/`: 存放服务端模板文件（如 Thymeleaf, FreeMarker），用于服务端渲染页面（在这个项目中，由于使用了 Vue.js 做前端，这个目录可能为空或不常用）。
        *   `mapper/` 或类似的目录: 可能存放 MyBatis 的 XML 映射文件，定义了 SQL 语句。
    *   `src/test/`: 存放测试代码。

2.  **`pom.xml`:** Maven 的核心配置文件。定义了项目信息、依赖库 (如 Spring Boot, MyBatis, MySQL 驱动等)、插件和构建规则。通过阅读它，我们可以精确了解项目引入了哪些第三方库及其版本。

3.  **文档文件:**
    *   `项目需求.md`, `项目进度.md`, `数据库设计.md`, `项目文档.md`: 这些 Markdown 文件提供了项目不同层面的文字说明。
    *   `接口API文档.json`, `swagger3.json`: API 接口的定义文件，非常重要，用于理解后端提供了哪些服务。

4.  **构建与环境相关:**
    *   `.mvn/`, `mvnw`, `mvnw.cmd`: Maven Wrapper 相关文件，使得在没有全局安装 Maven 的情况下也能构建项目。
    *   `target/`: Maven 构建输出目录，存放编译后的 `.class` 文件、打包后的 `.jar` 或 `.war` 文件等。这个目录通常不需要手动修改，可以被清理和重新生成。
    *   `.gitignore`: Git 忽略文件配置。
    *   `.idea/`, `.vscode/`: IDE 配置文件。

**前后端代码位置:**

*   **后端代码** 位于 `backend/` 目录中，是一个独立的 Maven Java 项目。
*   **前端代码 (Vue.js)** 位于与 `backend/` 同级的 `frontend/` 目录中，是一个独立的基于 Vite 的 Node.js 项目。
*   (注：在本次学习讨论中，前端代码暂时被放置在 `backend/frontend/` 目录下以便查看，但实际结构中前后端是分离且同级的。)

**总结:** 项目结构遵循了典型的 Maven Java 项目布局，后端代码和资源集中在 `src/` 目录下。核心配置在 `pom.xml` 和 `application.properties/yml` 中。理解这个结构后，我们可以更容易地找到特定功能的代码或配置文件。

## 第二部分：核心数据模型

**目标：** 理解项目数据的组织方式、表结构以及它们之间的关联关系。

**核心数据模型 (基于 `数据库设计.md`)**

`数据库设计.md` 文件中提供了创建数据库表的 SQL 语句 (CREATE TABLE)。这些语句不仅定义了每个表包含哪些字段（列），还定义了字段的数据类型、约束（如是否允许为空、是否唯一）、以及表之间的关系（外键）。

### 2.1 数据库设计详解 (Part 1: 用户、影院、影厅)

让我们逐个分析主要的表及其关系：

1.  **`user` 表 (用户表):**
    *   **作用:** 存储所有类型的用户信息（普通用户、影院管理员、系统管理员）。
    *   **关键字段:**
        *   `id`: 用户唯一标识符 (主键)。
        *   `username`: 登录名，唯一。
        *   `password`: 登录密码 (需要加密存储)。
        *   `nickname`, `avatar`, `phone`, `email`: 用户基本信息。
        *   `role`: **非常重要**，使用 `ENUM` 类型定义了用户的角色 (`USER`, `CINEMA_ADMIN`, `SYSTEM_ADMIN`)。这是实现权限控制的基础。
    *   **关联:**
        *   与 `cinema` 表通过 `admin_user_id` 关联 (一个影院管理员对应一个用户)。
        *   与 `t_order` 表通过 `user_id` 关联 (一个用户可以有多个订单)。
        *   与 `favorite` 表通过 `user_id` 关联 (一个用户可以收藏多个电影)。
        *   与 `rating` 表通过 `user_id` 关联 (一个用户可以评价多个电影)。
        *   与 `seat_lock` 表通过 `user_id` 关联 (一个用户可以锁定多个座位)。
        *   与 `announcement` 表通过 `publisher_id` 关联 (一个系统管理员可以发布多个公告)。

2.  **`cinema` 表 (影院信息表):**
    *   **作用:** 存储影院的基本信息及其状态。
    *   **关键字段:**
        *   `id`: 影院唯一标识符 (主键)。
        *   `name`, `address`, `phone`, `logo`, `description`: 影院基本信息。
        *   `admin_user_id`: 关联到 `user` 表的影院管理员 ID (唯一约束意味着一个用户只能管理一个影院)。
        *   `status`: **重要**，使用 `ENUM` 定义影院的认证状态 (`PENDING_APPROVAL`, `APPROVED`, `REJECTED`, `DISABLED`)。这体现了影院入驻需要审批的业务流程。
    *   **关联:**
        *   与 `user` 表通过 `admin_user_id` 关联。
        *   与 `room` 表通过 `cinema_id` 关联 (一个影院可以有多个影厅)。
        *   与 `screening` 表通过 `cinema_id` 关联 (一个影院可以有多个放映场次)。
        *   与 `t_order` 表通过 `cinema_id` 关联 (一个影院可以有多个订单)。

3.  **`room` 表 (影厅信息表):**
    *   **作用:** 存储影院的影厅信息，包括座位布局。
    *   **关键字段:**
        *   `id`: 影厅唯一标识符 (主键)。
        *   `cinema_id`: 所属影院 ID (外键)。
        *   `name`: 影厅名称 (如 "1号厅")。
        *   `rows_count`, `cols_count`: 定义了影厅的座位行数和列数 (默认 8x8)。
        *   `seat_template`: JSON 类型，用于存储特殊的座位布局信息（比如某些位置没有座位，或是情侣座等）。
    *   **关联:**
        *   与 `cinema` 表通过 `cinema_id` 关联。
        *   与 `screening` 表通过 `room_id` 关联 (一个影厅可以安排多个放映场次)。

**初步总结:** 我们分析了用户、影院、影厅这三个基础信息表。可以看到，通过 `id` (主键) 和 `xxx_id` (外键) 以及 `ENUM` 类型的状态字段，数据库清晰地定义了数据的基本结构、关联关系和一些业务状态。

### 2.1 数据库设计详解 (Part 2: 电影、类型、演职人员)

接下来我们分析与电影信息本身相关的表：

4.  **`movie_type` 表 (电影类型表):**
    *   **作用:** 存储电影的分类信息，如喜剧、动作、科幻等。这是一个基础数据表。
    *   **关键字段:**
        *   `id`: 类型唯一标识符 (主键)。
        *   `name`: 类型名称 (唯一)。
        *   `tmdb_genre_id`: 对应 The Movie Database (TMDB) API 的类型 ID。这表明项目可能从 TMDB 同步电影类型数据。
    *   **关联:**
        *   与 `movie_movie_type` 表通过 `movie_type_id` 关联。

5.  **`movie` 表 (电影信息表):**
    *   **作用:** 存储电影的核心信息。这是系统中最核心的表之一。
    *   **关键字段:**
        *   `id`: 电影唯一标识符 (主键)。
        *   `title`, `director`, `actors`, `duration`, `description`, `poster_url`, `release_date`, `country`, `trailer_url`: 电影的基本属性。
        *   `status`: **重要**，使用 `ENUM` 定义电影的状态 (`COMING_SOON`, `NOW_PLAYING`, `OFFLINE`)，用于控制电影是否在前台展示、是否可排片等。
        *   `tmdb_id`: TMDB API 的电影 ID (唯一)。再次印证了项目可能依赖 TMDB 获取电影基础数据。
        *   `tmdb_vote_average`, `tmdb_vote_count`, `tmdb_popularity`: 从 TMDB 同步的评分、评分人数和热度值。
        *   `total_box_office`: 累计票房。这个字段的值**不会自动更新**，需要通过业务逻辑（例如，订单完成后累加）来维护。
        *   `average_rating`: 本站用户平均评分。同样需要通过业务逻辑（例如，用户提交评分后重新计算）来维护。
    *   **关联:**
        *   与 `movie_movie_type` 表通过 `movie_id` 关联 (一个电影可以属于多个类型)。
        *   与 `credit` 表通过 `movie_id` 关联 (一个电影有多条演职人员记录)。
        *   与 `screening` 表通过 `movie_id` 关联 (一个电影可以安排多个放映场次)。
        *   与 `t_order` 表通过 `movie_id` 关联 (一个电影可以对应多个订单)。
        *   与 `favorite` 表通过 `movie_id` 关联 (一个电影可以被多个用户收藏)。
        *   与 `rating` 表通过 `movie_id` 关联 (一个电影可以收到多个用户的评分)。

6.  **`movie_movie_type` 表 (电影与类型关联表):**
    *   **作用:** 这是典型的**中间表 (Junction Table)**，用于表示 `movie` 和 `movie_type` 之间的**多对多关系** (一个电影可以有多个类型，一个类型也可以包含多个电影)。
    *   **关键字段:**
        *   `movie_id`: 关联到 `movie` 表的 ID。
        *   `movie_type_id`: 关联到 `movie_type` 表的 ID。
        *   `PRIMARY KEY (movie_id, movie_type_id)`: 使用联合主键确保同一部电影和同一类型的关联关系是唯一的。
    *   **关联:** 连接 `movie` 表和 `movie_type` 表。

7.  **`credit` 表 (演职人员表):**
    *   **作用:** 存储电影的演职人员信息（导演、演员等）及其扮演的角色。
    *   **关键字段:**
        *   `id`: 演职人员记录的唯一标识符 (主键)。
        *   `movie_id`: 关联的电影 ID (外键)。
        *   `tmdb_person_id`, `tmdb_credit_id`: TMDB 的人物 ID 和在该电影中的具体演职条目 ID，进一步证实了 TMDB 数据源的使用。
        *   `name`, `role`, `character_name`, `avatar_url`: 演职人员的基本信息。
    *   **关联:**
        *   与 `movie` 表通过 `movie_id` 关联。

**初步总结:** 这一组表清晰地定义了电影本身的信息、分类以及相关的演职人员。`movie_movie_type` 中间表的使用是处理多对多关系的典型方式。TMDB 相关字段的存在强烈暗示了项目会利用外部 API 来丰富电影数据。同时，`total_box_office` 和 `average_rating` 这类统计字段需要后端业务逻辑来维护更新。

### 2.1 数据库设计详解 (Part 3: 放映场次、订单与座位)

接下来分析与放映场次、票务和订单相关的表，这些表构成了电影院购票系统的交易核心：

8.  **`screening` 表 (放映场次表):**
    *   **作用:** 存储电影的具体放映信息，包括时间、地点、价格等。这是售票和选座的核心表。
    *   **关键字段:**
        *   `id`: 场次唯一标识符 (主键)。
        *   `movie_id`: 电影 ID (外键)。
        *   `room_id`: 影厅 ID (外键)。
        *   `cinema_id`: 影院 ID (外键)。尽管可以通过 `room_id` 间接找到 `cinema_id`，但这里直接存储是为了提高查询效率，属于**数据冗余**设计。
        *   `start_time`, `end_time`: 放映的开始和结束时间。
        *   `price`: 本场次的票价。
        *   `status`: **重要**，使用 `ENUM` 定义场次状态 (`PENDING_APPROVAL`, `APPROVED`, `REJECTED`, `FINISHED`, `CANCELLED`)。说明每个放映场次需要经过审批流程。
    *   **关联:**
        *   与 `movie` 表通过 `movie_id` 关联。
        *   与 `room` 表通过 `room_id` 关联。
        *   与 `cinema` 表通过 `cinema_id` 关联。
        *   与 `t_order` 表通过 `screening_id` 关联 (一个场次可能有多个订单)。
        *   与 `order_seat` 表通过 `screening_id` 关联 (一个场次有多个已售座位记录)。
        *   与 `seat_lock` 表通过 `screening_id` 关联 (一个场次可能有多个临时锁定的座位)。
    *   **索引:**
        *   `idx_screening_start_time`: 用于基于开始时间的查询 (如按日期查询场次)。
        *   `idx_screening_movie_cinema`: 用于基于电影和影院的联合查询 (如查询某影院某电影的所有场次)。

9.  **`t_order` 表 (订单表):**
    *   **作用:** 存储用户的购票订单信息。使用 `t_order` 而非 `order` 是为了避免与 SQL 关键字冲突。
    *   **关键字段:**
        *   `id`: 订单唯一标识符 (主键)。
        *   `order_no`: 订单号 (业务生成，唯一)。这是面向用户的订单标识，常用于支付、查询等流程。
        *   `user_id`: 下单用户 ID (外键)。
        *   `screening_id`: 关联场次 ID (外键)。
        *   `cinema_id`, `movie_id`: 冗余字段，存储关联的影院 ID 和电影 ID，用于提高查询效率。
        *   `total_amount`: 订单总金额。
        *   `seat_count`: 座位数量。
        *   `status`: **重要**，使用 `ENUM` 定义订单状态 (`PENDING_PAYMENT`, `PAID`, `CANCELLED`, `REFUNDED`, `COMPLETED`)。体现了订单的生命周期。
        *   `payment_time`, `cancel_time`: 订单支付时间和取消时间，仅在相应状态下有值。
    *   **关联:**
        *   与 `user` 表通过 `user_id` 关联。
        *   与 `screening` 表通过 `screening_id` 关联。
        *   与 `cinema` 表通过 `cinema_id` 关联。
        *   与 `movie` 表通过 `movie_id` 关联。
        *   与 `order_seat` 表通过 `order_id` 关联 (一个订单对应多个座位)。
    *   **索引:**
        *   `idx_order_user_id`: 用于查询用户的所有订单。
        *   `idx_order_screening_id`: 用于查询场次的所有订单。

10. **`order_seat` 表 (订单座位表):**
    *   **作用:** 记录每个订单锁定了哪些具体的座位，是 `t_order` 和具体座位位置的关联表。
    *   **关键字段:**
        *   `id`: 记录唯一标识符 (主键)。
        *   `order_id`: 关联的订单 ID (外键)。
        *   `screening_id`: 场次 ID (外键，冗余字段)。同样是为了提高查询效率，例如快速找到某场次的所有已售座位。
        *   `row_index`, `col_index`: 座位的行号和列号 (均从1开始)。
        *   `seat_label`: 座位标签 (如 "A1", "B5")，可以根据行列号生成，方便显示。
    *   **关键约束:**
        *   `UNIQUE KEY uk_screening_seat (screening_id, row_index, col_index)`: 确保同一场次的同一个座位只能被售出一次。
    *   **关联:**
        *   与 `t_order` 表通过 `order_id` 关联。
        *   与 `screening` 表通过 `screening_id` 关联。

11. **`seat_lock` 表 (座位锁定表):**
    *   **作用:** 用于临时锁定用户选中但尚未付款的座位，防止其他用户同时选择。这是实现选座功能的关键表。
    *   **关键字段:**
        *   `id`: 锁定记录唯一标识符 (主键)。
        *   `screening_id`: 关联的场次 ID (外键)。
        *   `row_index`, `col_index`: 座位的行号和列号。
        *   `user_id`: 锁定座位的用户 ID (外键)。
        *   `lock_expiry_time`: **非常重要**，锁定过期时间。超过这个时间，锁定自动失效，座位可被其他人选择。
    *   **关键约束:**
        *   `UNIQUE KEY uk_screening_seat_lock (screening_id, row_index, col_index)`: 确保同一场次的同一个座位只能被一个用户锁定。
    *   **索引:**
        *   `idx_lock_expiry_time`: 用于定期清理过期锁定的任务。
        *   `idx_lock_user_screening`: 用于查询某用户在某场次锁定的所有座位。
    *   **关联:**
        *   与 `screening` 表通过 `screening_id` 关联。
        *   与 `user` 表通过 `user_id` 关联。

**座位选择与锁定流程:**

从上述表结构，我们可以推断出系统的座位选择与锁定流程：

1.  用户选择电影/影院/场次后，系统从 `screening` 表获取场次信息，从 `room` 表获取影厅行列数，从 `order_seat` 表获取已售座位。
2.  用户选择座位后，系统在 `seat_lock` 表创建临时锁定记录，设置一个短期的过期时间 (如15分钟)。
3.  用户完成付款后，系统创建 `t_order` 表记录和对应的 `order_seat` 表记录，并删除 `seat_lock` 表中的临时锁定。
4.  如果用户未在规定时间内完成付款，锁定自动过期，座位可被其他用户选择。可能有定时任务负责清理过期锁定。

**初步总结:** 这组表实现了购票的核心流程：场次排片→座位选择→下单→支付。`seat_lock` 表的设计特别值得注意，它解决了并发选座的问题。同时，多处使用了冗余字段来提高查询效率，这是实际系统中常见的优化手段。

### 2.1 数据库设计详解 (Part 4: 收藏、评分与公告)

接下来分析与用户交互和系统通知相关的表：

12. **`favorite` 表 (电影收藏表):**
    *   **作用:** 记录用户收藏的电影，实现"我想看"的功能。
    *   **关键字段:**
        *   `user_id`: 用户 ID (外键)。
        *   `movie_id`: 电影 ID (外键)。
        *   `create_time`: 收藏创建时间。
        *   `PRIMARY KEY (user_id, movie_id)`: 使用联合主键，确保一个用户不能重复收藏同一部电影。
    *   **关联:**
        *   与 `user` 表通过 `user_id` 关联。
        *   与 `movie` 表通过 `movie_id` 关联。
    *   **业务场景:**
        *   用户可以在电影详情页点击"想看"按钮添加收藏。
        *   在"我的收藏"页面查看所有收藏的电影。
        *   通过收藏数据，系统可以分析电影的受欢迎程度。

13. **`rating` 表 (电影评分表):**
    *   **作用:** 存储用户对电影的评分和评论。
    *   **关键字段:**
        *   `id`: 评分记录唯一标识符 (主键)。
        *   `user_id`: 用户 ID (外键)。
        *   `movie_id`: 电影 ID (外键)。
        *   `score`: 评分 (1-10 整数)。
        *   `comment`: 评论内容 (可选)。
        *   `create_time`, `update_time`: 创建和更新时间。
        *   `UNIQUE KEY uk_user_movie_rating (user_id, movie_id)`: 确保同一用户只能对同一部电影评分一次。
    *   **关联:**
        *   与 `user` 表通过 `user_id` 关联。
        *   与 `movie` 表通过 `movie_id` 关联。
    *   **索引:**
        *   `idx_rating_movie_id`: 用于快速查询某电影的所有评分记录。
    *   **业务场景:**
        *   用户观影后可以对电影进行评分和评论。
        *   系统根据所有用户的评分计算电影的平均分，并更新 `movie` 表中的 `average_rating` 字段。
        *   电影详情页展示评分和评论信息。

14. **`announcement` 表 (公告信息表):**
    *   **作用:** 存储系统公告信息，用于向用户和影院管理员发布重要通知。
    *   **关键字段:**
        *   `id`: 公告唯一标识符 (主键)。
        *   `title`: 公告标题。
        *   `content`: 公告内容。
        *   `publisher_id`: 发布者 ID (外键，通常是系统管理员)。
        *   `is_published`: 是否发布的状态标志。
        *   `publish_time`: 发布时间。
        *   `create_time`, `update_time`: 创建和更新时间。
    *   **关联:**
        *   与 `user` 表通过 `publisher_id` 关联。
    *   **业务场景:**
        *   系统管理员在后台创建公告，设置标题和内容。
        *   公告可以先保存为草稿 (`is_published = FALSE`)，后续发布。
        *   发布后，公告会显示在首页或公告专区，所有用户可见。
        *   影院管理员需要定期查看公告，了解系统最新规则或通知。

**小结:** 以上三个表实现了系统的用户互动功能（收藏、评分评论）和平台通知机制（公告）。这些功能增强了用户体验，提供了更多用户与平台的互动方式，同时也为系统运营提供了数据支持（如哪些电影更受欢迎）和通知渠道。

### 2.2 实体关系梳理

在分析完所有表之后，我们可以梳理出整个系统的核心实体及其关系：

**核心实体:**

1.  **用户 (`user`)**：系统的所有用户，包括普通用户、影院管理员、系统管理员。
2.  **电影 (`movie`)**：核心业务对象，包含基本信息、状态等。
3.  **电影类型 (`movie_type`)**：电影的分类标签。
4.  **影院 (`cinema`)**：提供放映服务的场所。
5.  **影厅 (`room`)**：影院中的放映厅，包含座位布局。
6.  **放映场次 (`screening`)**：特定电影在特定影厅的具体放映时间和价格。
7.  **订单 (`t_order`)**：用户购票的交易记录。
8.  **座位 (`order_seat`, `seat_lock`)**：影厅中的具体座位位置，可能被售出或临时锁定。

**主要关系:**

1.  **一对多关系:**
    *   一个用户 → 多个订单
    *   一个电影 → 多个放映场次
    *   一个电影 → 多个演职人员记录
    *   一个影院 → 多个影厅
    *   一个影院 → 多个放映场次
    *   一个影厅 → 多个放映场次
    *   一个放映场次 → 多个订单
    *   一个订单 → 多个座位

2.  **多对多关系:**
    *   电影 ↔ 电影类型 (通过 `movie_movie_type` 关联)
    *   用户 ↔ 电影(收藏) (通过 `favorite` 关联)
    *   用户 ↔ 电影(评分) (通过 `rating` 关联)

3.  **特殊关系:**
    *   一个影院管理员用户 → 一个影院 (一对一关系)
    *   一个系统管理员 → 多个公告

**状态流转:**

系统中多个实体有状态字段，表示业务流程中的不同阶段：

1.  **影院状态:** `PENDING_APPROVAL` → `APPROVED`/`REJECTED` → 可能变为 `DISABLED`
2.  **电影状态:** `COMING_SOON` → `NOW_PLAYING` → `OFFLINE`
3.  **放映场次状态:** `PENDING_APPROVAL` → `APPROVED`/`REJECTED` → 可能变为 `FINISHED`/`CANCELLED`
4.  **订单状态:** `PENDING_PAYMENT` → `PAID`/`CANCELLED` → 可能变为 `COMPLETED`/`REFUNDED`

**数据处理特点:**

1.  **冗余设计:** 为了提高查询效率，多处使用了冗余字段 (如 `screening` 表中的 `cinema_id`, `order_seat` 表中的 `screening_id`)。
2.  **复合索引:** 针对高频查询场景设置了合适的索引 (如 `idx_screening_movie_cinema`)。
3.  **唯一约束:** 使用联合主键或唯一索引确保数据的一致性 (如 `uk_screening_seat`)。
4.  **统计字段:** `movie` 表中的 `total_box_office` 和 `average_rating` 需要通过业务逻辑维护。
5.  **业务规则体现:** `seat_lock` 表中的 `lock_expiry_time` 体现了座位锁定的业务规则。

**总结:** 这个数据库设计紧密围绕"用户-影院-电影-场次-订单"这条主线，通过外键关系和状态标记，清晰地定义了各实体间的关联和业务流程。设计既考虑了实体间的逻辑关系，也兼顾了查询性能和数据一致性，是一个较为完善的电影购票系统数据模型。

---

**用户提问:** 请问在电影信息相关表中的TMBD id是为了在填充数据时能正确匹配吗？

### TMDB ID的作用分析

是的，您观察得非常准确。在电影相关的表（如`movie`、`movie_type`和`credit`表）中出现的TMDB相关ID字段，确实主要是为了在从外部数据源填充和更新数据时能够正确匹配。TMDB（The Movie Database）是一个流行的电影和电视剧数据库，提供了丰富的API，许多电影相关应用都会使用它来获取数据。

**TMDB相关字段及其作用:**

1. **`movie` 表中的 `tmdb_id`:**
   * 用于唯一标识从TMDB获取的电影。
   * 确保同一部电影不会被重复导入系统。
   * 便于后续根据TMDB更新的数据刷新本地电影信息。

2. **`movie_type` 表中的 `tmdb_genre_id`:**
   * 映射TMDB中的电影类型ID，确保类型信息与外部数据一致。
   * 在导入电影时，可以根据此ID正确关联电影类型。

3. **`credit` 表中的 `tmdb_person_id` 和 `tmdb_credit_id`:**
   * `tmdb_person_id`标识演员/导演等人物在TMDB中的唯一ID。
   * `tmdb_credit_id`标识特定电影中特定人物的演职信息的唯一ID。
   * 这些ID帮助系统正确导入和更新演职人员信息。

**这种设计带来的好处:**

1. **数据导入与同步:**
   * 可以编写脚本或定时任务，定期从TMDB API获取最新电影信息。
   * 使用TMDB ID作为关键匹配字段，决定是新增还是更新已有记录。

2. **避免数据重复:**
   * 通过检查TMDB ID是否已存在于数据库中，避免同一资源被重复导入。

3. **资源关联:**
   * 可以直接使用TMDB的资源链接（如电影海报、演员照片等），减少本地存储需求。
   * 例如`movie`表中的`poster_url`和`credit`表中的`avatar_url`可能直接使用TMDB的图片路径。

4. **数据一致性:**
   * 确保系统内的电影信息与TMDB保持一致，包括名称、类型、演员等信息。

5. **初始数据填充:**
   * 对于新上线的系统，可以快速从TMDB导入大量高质量的电影基础数据，而不需要手动录入。

从`项目进度.md`中可以看到，该项目确实有一个"**TMDB API 集成**"的任务（2.8节），专门用于"编写逻辑调用TMDB API，为数据库填充初始电影、类型、演职员数据"。这进一步证实了我们的分析：TMDB ID字段的存在就是为了支持从TMDB API导入数据并保持同步。

---

**用户提问:** 请按照 @项目拆解规划.md 为我安排下一节课。
另外，需要你根据 @接口API文档.json 和 @项目进度.md 为 @项目拆解规划.md 完善课程，要求涵盖到项目的每一个细节。

## 第三部分：后端 - 基础与认证

**目标:** 理解项目后端架构，特别是Spring Boot框架的配置与用户认证实现方式。

### 3.1 Spring Boot 核心概念与项目配置

#### Spring Boot简介

Spring Boot是一个用于快速构建基于Spring框架项目的工具，它大大简化了Spring应用的初始化、配置和开发过程。相较于传统的Spring应用，它提供了以下几个核心优势：

1. **自动配置:** 根据项目依赖自动配置Spring应用。
2. **内嵌服务器:** 内置Tomcat、Jetty或Undertow，无需部署WAR文件。
3. **"约定优于配置":** 提供合理的默认配置，减少开发者的决策需求。
4. **无需XML配置:** 使用注解和Java配置类代替XML配置。
5. **丰富的Starter依赖:** 提供一系列"starter"依赖简化构建配置。

#### 核心概念

在深入代码前，先简要理解几个Spring的基础概念：

**1. IoC (控制反转):**
- 传统编程：开发者创建和管理对象及其依赖关系
- IoC方式：由Spring容器控制对象的创建和管理
- 好处：降低代码耦合度，提高模块化程度，便于测试

**2. DI (依赖注入):**
- IoC的一种实现方式
- Spring自动将对象的依赖"注入"到需要它们的地方
- 主要注入方式：构造器注入、Setter注入、字段注入
- 注解：`@Autowired`, `@Resource`, `@Inject`

**3. Bean:**
- 由Spring IoC容器实例化、组装和管理的对象
- 通过`@Component`, `@Service`, `@Repository`, `@Controller`等注解定义

**4. AOP (面向切面编程):**
- 将横切关注点(如日志、事务)与业务逻辑分离
- 无需修改核心业务代码即可添加功能
- 常用于：日志记录、事务管理、安全控制、性能监控

**代码体现:**
* **IoC/DI:** 在项目的 Service 类（如 `src/main/java/com/backend/backend/service/impl/UserServiceImpl.java`）中，你会看到使用 `@Autowired` 或构造函数注入其他 Bean（如 Mapper）。
* **Bean:** 核心组件通过注解标识，例如：
    * `@Service` 在业务逻辑类上 (e.g., 在 `src/main/java/com/backend/backend/service` 目录下的服务类)
    * `@RestController` 在 API 接口类上 (e.g., `src/main/java/com/backend/backend/controller` 目录下的控制器类)
    * `@Repository` 或 `@Mapper` 在数据访问接口上 (e.g., `src/main/java/com/backend/backend/mapper` 目录下的接口)
* **AOP:** 虽然基础项目中可能不明显，但 Spring 框架内部大量使用 AOP 实现事务管理 (`@Transactional`)、安全控制等。项目可能在 `config` 目录中有相关配置。

#### 项目配置分析

主要配置文件是位于`src/main/resources/`目录下的`application.yml`(或`application.properties`)。

**示例 (`src/main/resources/application.yml`):**

1. **数据库连接 (`spring.datasource`):**
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/movie_booking?useSSL=false&serverTimezone=UTC # 数据库 URL
    username: root # 用户名
    password: yourpassword # 密码
    driver-class-name: com.mysql.cj.jdbc.Driver # 驱动类
```

2. **MyBatis配置 (`mybatis`):**
```yaml
mybatis:
  mapper-locations: classpath:mapper/*.xml # 指定 Mapper XML 文件位置 (通常在 src/main/resources/mapper/ 下)
  type-aliases-package: com.backend.backend.entity # 指定实体类包路径
  configuration:
    map-underscore-to-camel-case: true # 开启下划线到驼峰命名自动映射
```

3. **服务器配置 (`server`):**
```yaml
server:
  port: 8080 # 应用监听端口
  servlet:
    context-path: /api # 应用上下文路径，所有 API 都在 /api/ 下
```

4. **日志配置 (`logging.level`):**
```yaml
logging:
  level:
    root: INFO # 全局日志级别
    com.backend.backend: DEBUG # 指定项目包的日志级别为 DEBUG，方便调试
```

5. **安全和JWT配置 (`jwt`):**
```yaml
jwt:
  secret: yourSecretKey # JWT 签名密钥 (应使用更安全的方式管理)
  expiration: 86400000  # Token 过期时间 (毫秒)
```

#### 依赖分析 (`pom.xml`)

核心依赖定义在项目根目录的 `pom.xml` 文件中：

1. **Spring Boot Web Starter:**
```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

2. **数据库相关 Starter:**
```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>...</version> <!-- 版本号 -->
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
```

3. **安全相关 Starter:**
```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId> <!-- 推荐使用 jjwt-api, jjwt-impl, jjwt-jackson -->
    <version>...</version>
</dependency>
```

4. **Lombok (简化代码):**
```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

#### 项目启动流程

启动入口是根包下的 `BackendApplication.java`：

```java
// BackendApplication.java
package com.backend.backend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // 核心注解
public class BackendApplication {

    public static void main(String[] args) {
        SpringApplication.run(BackendApplication.class, args);
    }

}
```

`@SpringBootApplication` 包含了 `@ComponentScan`，默认会扫描 `BackendApplication.java` 所在的包 (`com.backend.backend`) 及其所有子包下的组件（`@Service`, `@Controller` 等）。

#### 总结

Spring Boot 通过 `pom.xml` 管理依赖，通过 `application.yml` 进行配置，并通过 `@SpringBootApplication` 注解启动整个应用。其核心特性 IoC 和 DI 使得代码解耦，AOP 提供了横切关注点的能力。理解这些基础是深入后端代码的前提。

---
